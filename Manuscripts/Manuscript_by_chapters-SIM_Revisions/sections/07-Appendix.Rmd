# (APPENDIX) Appendix {-}

<!-- allows for page numbering using letters for the Appendix -->
\appendixpagenumbering

<!-- Allows for figure numbers with letters for Appendix -->
\counterwithin{figure}{section}
# APPENDIX

This section presents the code used to generate figures, models and simulated data from the main manuscript.

## Compound symmetry and independent errors in linear and quadratic responses

This section simulates linear and quadratic data in the same manner as in Section \@ref(simulation) in the main manuscript. The linear simulations using Figure \@ref(fig:linear-cases-Appendix) show in panels A and D the simulated mean responses and individual data points.  Panels C and G show a visual interpretation of "correlation" in the responses: In panel C, subjects that have a value of the random error $\varepsilon$ either above or below the mean group response are more likely to have other observations that follow the same trajectory, thereby demonstrating correlation in the response. In panel G,because the errors are independent, there is no expectation that responses are likely to follow a similar pattern.  Panels D and H show the predictions from the rm-ANOVA model.

The following code chunks produce a more comprehensive exploration of Figure \@ref(fig:l-q-response) in the main manuscript.

First, a function is created to simulate data across six timepoints using a linear or quadratic mean response, with correlated or uncorrelated errors. Each group has a different slope/concavity. The main function is the same for both groups, but a change in the sign allows to invert the trend.


```{r, responses-Appendix,include=TRUE,message=FALSE,echo=TRUE}
##########Section for calculations###########

<<testing>>
## Example with linear response

#This function simulates data using a linear or quadratic mean response and each with correlated
#or uncorrelated errors. Each group has a different slope/concavity.
example <- function(n_time = 6, #number of time points
                    fun_type = "linear", #type of response
                    error_type = "correlated") {
  
  if (!(fun_type %in% c("linear", "quadratic")))
    stop('fun_type must be either "linear", or "quadratic"')
  if (!(error_type %in% c("correlated", "independent")))
    stop('fun_type must be either "correlated", or "independent"')
  
  
  x <- seq(1,6, length.out = n_time)
  
  #Create mean response matrix: linear or quadratic
  mu <- matrix(0, length(x), 2)
  # linear response
  if (fun_type == "linear") {
    mu[, 1] <- - (0.25*x)+2  
    mu[, 2] <- 0.25*x+2
  } else {
    # quadratic response (non-linear)
    
    mu[, 1] <-  -(0.25 * x^2) +1.5*x-1.25
    mu[, 2] <- (0.25 * x^2) -1.5*x+1.25
  }
  
 
  #create an array where individual observations per each time point for each group are to be stored. Currently using 10 observations per timepoint
  y <- array(0, dim = c(length(x), 2, 10))
  
  #Create array to store the "errors" for each group at each timepoint. The "errors" are the 
  #between-group variability in the response.
  errors <- array(0, dim = c(length(x), 2, 10))
  #create an array where 10 observations per each time point for each group are to be stored
  
  #The following loops create independent or correlated responses. To each value of mu (mean response per group) a randomly generated error (correlated or uncorrelated) is added and thus the individual response is created.
  if (error_type == "independent") {
    ## independent errors
    for (i in 1:2) {
      for (j in 1:10) {
        errors[, i, j] <- rnorm(6, 0, 0.25)
        y[, i, j] <- mu[, i] + errors[, i, j]
      }
    }
  } else {
    for (i in 1:2) {     # number of treatments
      for (j in 1:10) {  # number of subjects
        # compound symmetry errors: variance covariance matrix
        errors[, i, j] <- rmvn(1, rep(0, length(x)), 0.1 * diag(6) + 0.25 * matrix(1, 6, 6))
        y[, i, j] <- mu[, i] + errors[, i, j]
      }
    }
  }    
  
  
  ## subject random effects
  
  ## visualizing the difference between independent errors and compound symmetry
  ## why do we need to account for this -- overly confident inference
  
#labeling y and errors  
  dimnames(y) <- list(time = x, 
                      treatment = 1:2, 
                      subject = 1:10)

  dimnames(errors) <- list(time = x, 
                           treatment = 1:2, 
                           subject = 1:10)
  
  #labeling the mean response
  dimnames(mu) <- list(time = x, 
                       treatment = 1:2)
  
  #convert y, mu and errors to  dataframes with time, treatment and subject columns
  dat <- as.data.frame.table(y, 
                             responseName = "y")
  dat_errors <- as.data.frame.table(errors, 
                                    responseName = "errors")
  dat_mu <- as.data.frame.table(mu, 
                                responseName = "mu")
  
  #join the dataframes to show mean response and errors per subject
  dat <- left_join(dat, dat_errors, 
                   by = c("time", "treatment", "subject"))
  dat <- left_join(dat, dat_mu, 
                   by = c("time", "treatment"))
  #add time
  dat$time <- as.numeric(as.character(dat$time))
  #label subjects per group
  dat <- dat %>%
    mutate(subject = factor(paste(subject, 
                                  treatment, 
                                  sep = "-")))
  
  
  ## repeated measures ANOVA 
  
  fit_anova <- lm(y ~ time + treatment + time * treatment, data = dat)
  
#LMEM: time and treatment interaction model, compound symmetry 
  fit_lme <- lme(y ~ treatment + time + treatment:time,
                 data = dat,
                 random = ~ 1 | subject,
                 correlation = corCompSymm(form = ~ 1 | subject)
  )
  
  #create a prediction frame where the model can be used for plotting purposes
  pred_dat <- expand.grid(
    treatment = factor(1:2), 
    time = unique(dat$time)
  )
  
  #add model predictions to the dataframe that has the simulated data
  dat$pred_anova <- predict(fit_anova)
  dat$pred_lmem <- predict(fit_lme)

  #return everything in a list
  return(list(
    dat = dat,
    pred_dat = pred_dat,
    fit_anova=fit_anova,
    fit_lme = fit_lme
  ))
}

##################Section for plotting#################################

#This function will create the plots for either a "linear" or "quadratic" response

plot_example <- function(sim_dat) {
  ## Plot the simulated data (scatterplot)
  txt<-20
  p1 <- sim_dat$dat %>%
    ggplot(aes(x = time, 
               y = y, 
               group = treatment, 
               color = treatment)
           ) +
    geom_point(show.legend=FALSE) +
    labs(y='response')+
    geom_line(aes(x = time, 
                  y = mu, 
                  color = treatment),
              show.legend=FALSE) +
    theme_classic() +
    theme(plot.title = element_text(size = txt, 
                                  face = "bold"),
        text=element_text(size=txt))+
    thm1
  
  #plot the simulated data with trajectories per each subject
  p2 <- sim_dat$dat %>%
    ggplot(aes(x = time, 
               y = y, 
               group = subject, 
               color = treatment)
           ) +
    geom_line(aes(size = "Subjects"),
              show.legend = FALSE) +
    # facet_wrap(~ treatment) +
    geom_line(aes(x = time, 
                  y = mu, 
                  color = treatment,
                  size = "Simulated Truth"), 
              lty = 1,show.legend = FALSE) +
    labs(y='response')+
    scale_size_manual(name = "Type", values=c("Subjects" = 0.5, "Simulated Truth" = 3)) +
    theme_classic()+
     theme(plot.title = element_text(size = txt, 
                                face = "bold"),
     text=element_text(size=txt))+
    thm1
  
  #plot the errors
   p3 <- sim_dat$dat %>%
    ggplot(aes(x = time, 
               y = errors,
               group = subject, 
               color = treatment)) +
    geom_line(show.legend=FALSE) +
     labs(y='errors')+
     theme_classic()+
     theme(plot.title = element_text(size = txt, 
                                  face = "bold"),
        text=element_text(size=txt))+
    thm1
  
   #plot the model predictions for rm-ANOVA
  p4 <- ggplot(sim_dat$dat, 
               aes(x = time, 
                   y = y, 
                   color = treatment)) +
    geom_point(show.legend=FALSE)+
    labs(y='response')+
    geom_line(aes(y = predict(sim_dat$fit_anova), 
                  group = subject, size = "Subjects"),show.legend = FALSE) +
    geom_line(data = sim_dat$pred_dat, 
              aes(y = predict(sim_dat$fit_anova, 
                              level = 0, 
                              newdata = sim_dat$pred_dat), 
                  size = "Population"),
              show.legend=FALSE) +
    guides(color = guide_legend(override.aes = list(size = 2)))+
    scale_size_manual(name = "Predictions", 
                      values=c("Subjects" = 0.5, "Population" = 3)) +
    theme_classic() +
    theme(plot.title = element_text(size = txt, 
                                  face = "bold"),
        text=element_text(size=txt))+
    thm1
   
   
   
   #plot the LMEM predictions
  p5 <- ggplot(sim_dat$dat, 
               aes(x = time, 
                   y = y, 
                   color = treatment)) +
    geom_point()+
    labs(y='response')+
    geom_line(aes(y = predict(sim_dat$fit_lme), 
                  group = subject, size = "Subjects")) +
    geom_line(data = sim_dat$pred_dat, 
              aes(y = predict(sim_dat$fit_lme, 
                              level = 0, 
                              newdata = sim_dat$pred_dat), 
                  size = "Population")) +
    guides(color = guide_legend(override.aes = list(size = 2)))+
    scale_size_manual(name = "Predictions", 
                      values=c("Subjects" = 0.5, "Population" = 3)) +
    theme_classic() +
    theme(plot.title = element_text(size = txt, 
                                  face = "bold"),
        text=element_text(size=txt))+
    thm1
  
  return((p1+p3+p2+p4+p5)+plot_layout(nrow=1)+plot_annotation(tag_levels = 'A')) 
  
    
}


#Store each plot in a separate object
A1<-plot_example(example(fun_type = "linear", error_type = "correlated")) 

B1<-plot_example(example(fun_type = "linear", error_type = "independent")) 
  
C1<-plot_example(example(fun_type = "quadratic", error_type = "correlated")) 
  
D1<-plot_example(example(fun_type = "quadratic", error_type = "independent")) 
  

```


(ref:linear-cases-appendix) Simulated linear responses from two groups with correlated (top row) or independent (bottom row) errors using a rm-ANOVA model and a LMEM. A, F:Simulated data with known mean response and individual responses (points) showing the dispersion of the data. B,G: Generated errors showing the difference in the behavior of correlated and independent errors. C,H: Simulated data with thin lines representing individual trajectories. D,I: Estimations from the rm-ANOVA model for the mean group response. E, J: Estimations from the LMEM for the mean group response and individual responses (thin lines). In all panels, thick lines are the predicted mean response per group, thin lines are the random effects for each subject and points represent the original raw data. Both rm-ANOVA and the LMEM are able to capture the trend of the data.


```{r, linear-cases-Appendix, fig.width=14, fig.height=12, out.width='100%',fig.align='center', echo=FALSE,message=FALSE,fig.show='hold',fig.cap='(ref:linear-cases-appendix)'}
# linear response, correlated errors (subject effect)
A1/B1+plot_annotation(tag_levels = 'A')
```


For the quadratic response case, Figure \@ref(fig:quadratic-cases-Appendix) shows the simulated responses using compound symmetry and independent errors. 


(ref:quadratic-caption-appendix) Simulated quadratic responses from two groups with correlated (top row) or independent (bottom row) errors using a rm-ANOVA model and a LMEM. A, F:Simulated data with known mean response and individual responses (points) showing the dispersion of the data. B,G: Generated errors showing the difference in the behavior of correlated and independent errors. C,H: Simulated data with thin lines representing individual trajectories. D,I: Estimations from the rm-ANOVA model for the mean group response. E, J: Estimations from the LMEM for the mean group response and individual responses (thin lines). In all panels, thick lines are the predicted mean response per group, thin lines are the random effects for each subject and points represent the original raw data. Both rm-ANOVA and the LMEM are not able to capture the changes in each group over time.


```{r, quadratic-cases-Appendix, fig.width=14, fig.height=12, out.width='100%',fig.align='center', echo=FALSE,message=FALSE,fig.show='hold',fig.cap='(ref:quadratic-caption-appendix)'}
# linear response, correlated errors (subject effect)
C1/D1+plot_annotation(tag_levels = 'A')
```


## Basis functions and GAMs

This code produces Figure \@ref(fig:basis-plot) from the main manuscript. Briefly, a non-linear (quadratic) response is simulated, a gam model is fitted and the basis are extracted in order to explain how the smooth is constructed. The code for data simulation is used again here for the sake of keeping the same structure, although the data can be simulated in a more simple fashion.


```{r,basis-Appendix, echo=TRUE,include=TRUE,message=FALSE,warning=FALSE,eval=FALSE}
#generate the response: the same initial procedure from the previous section to simulate
#the response
set.seed(1)
n_time = 6
 x <- seq(1,6, length.out = n_time)
 mu <- matrix(0, length(x), 2)
 mu[, 1] <-  -(0.25 * x^2) +1.5*x-1.25 #mean response
 mu[, 2] <- (0.25 * x^2) -1.5*x+1.25 #mean response
 y <- array(0, dim = c(length(x), 2, 10))
 errors <- array(0, dim = c(length(x), 2, 10))
 for (i in 1:2) {     # number of treatments
     for (j in 1:10) {  # number of subjects
         # compound symmetry errors
         errors[, i, j] <- rmvn(1, rep(0, length(x)), 0.1 * diag(6) + 0.25 * matrix(1, 6, 6))
         y[, i, j] <- mu[, i] + errors[, i, j]
     }
 }
 
 #label each table
  dimnames(y) <- list(time = x, treatment = 1:2, subject = 1:10)
 dimnames(errors) <- list(time = x, treatment = 1:2, subject = 1:10)
 dimnames(mu) <- list(time = x, treatment = 1:2)
 
 #Convert to dataframes with subject, time and group columns
 dat <- as.data.frame.table(y, responseName = "y")
 dat_errors <- as.data.frame.table(errors, responseName = "errors")
 dat_mu <- as.data.frame.table(mu, responseName = "mu")
 dat <- left_join(dat, dat_errors, by = c("time", "treatment", "subject"))
 dat <- left_join(dat, dat_mu, by = c("time", "treatment"))
 dat$time <- as.numeric(as.character(dat$time))
 
 #label subject per group
 dat <- dat %>%
     mutate(subject = factor(paste(subject, treatment, sep = "-")))
  
 #extract  "Group 1" to fit the GAM
  dat<-subset(dat,treatment==1)
 #keep just the response and timepoint columns
   dat<-dat[,c('y','time')]

   #GAM model of time, 5 basis
gm<-gam(y~s(time,k=5),data=dat)

#model_matrix (also known as) 'design matrix'
#will contain the smooths used to create  model 'gm'
model_matrix<-as.data.frame(predict(gm,type='lpmatrix'))


time<-c(1:6)

basis<-model_matrix[1:6,] #extracting basis (because the values are repeated after every 6 rows)
#basis<-model_matrix[1:6,-1] #extracting basis
colnames(basis)[colnames(basis)=="(Intercept)"]<-"s(time).0"
basis<-basis %>% #pivoting to long format
  pivot_longer(
    cols=starts_with("s")
  )%>%
  arrange(name) #ordering

#length of dataframe to be created: number of basis by number of timepoints (minus 1 for the intercept that we won't plot)
ln<-6*(length(coef(gm))) 

basis_plot<-data.frame(Basis=integer(ln),
                       value_orig=double(ln),
                       time=integer(ln),
                       cof=double(ln)
)

basis_plot$time<-rep(time) #pasting timepoints
basis_plot$Basis<-factor(rep(c(1:5),each=6)) #pasting basis number values
basis_plot$value_orig<-basis$value #pasting basis values
basis_plot$cof<-rep(coef(gm)[1:5],each=6) #pasting coefficients
basis_plot<-basis_plot%>%
  mutate(mod_val=value_orig*cof) #the create the predicted values the bases need to be 
#multiplied by the coefficients

#creating labeller to change the labels in the basis plots

basis_names<-c(
  `1`="Intercept",
  `2`="1",
  `3`="2",
  `4`="3",
  `5`="4"
)

#calculating the final smooth by aggregating the basis functions

smooth<-basis_plot%>% 
  group_by(time)%>%
  summarize(smooth=sum(mod_val))


#original basis
sz<-1
p11<-ggplot(basis_plot,
            aes(x=time,
                y=value_orig,
                colour=as.factor(Basis)
                )
            )+
  geom_line(size=sz,
            show.legend=FALSE)+
  geom_point(size=sz+1,
             show.legend = FALSE)+
  labs(y='Basis functions')+
  facet_wrap(~Basis,
             labeller = as_labeller(basis_names)
             )+
  theme_classic()+
  thm
  

#penalized basis
p12<-ggplot(basis_plot,
            aes(x=time,
                y=mod_val,
                colour=as.factor(Basis)
                )
            )+
  geom_line(show.legend = FALSE,
            size=sz)+
  geom_point(show.legend = FALSE,
             size=sz+1)+
  labs(y='Penalized \n basis functions')+
  scale_y_continuous(breaks=seq(-1,1,1))+
  facet_wrap(~Basis,
             labeller=as_labeller(basis_names)
             )+
  theme_classic()+
  thm

#heatmap of the coefficients
x_labels<-c("Intercept","1","2","3","4")
p13<-ggplot(basis_plot,
            aes(x=Basis,
                y=Basis))+
  geom_tile(aes(fill = cof), 
            colour = "black") +
    scale_fill_gradient(low = "white",
                        high = "#B50A2AFF")+ #color picked from KikiMedium
  labs(x='Basis',
       y='Basis')+
  scale_x_discrete(labels=x_labels)+
  geom_text(aes(label=round(cof,2)),
            size=7,
            show.legend = FALSE)+
  theme_classic()+
  theme(legend.title = element_blank())
  
#plotting simulated datapoints and smooth term
p14<-ggplot(data=dat,
            aes(x=time,y=y))+
  geom_point(size=sz+1)+
  labs(y='Simulated \n response')+
  geom_line(data=smooth,
            aes(x=time,
                y=smooth),
            color="#6C581DFF",
            size=sz+1)+
  theme_classic()
  

#Combining all
b_plot<-p11+p13+p12+p14+plot_annotation(tag_levels='A')&
  theme(
     text=element_text(size=18)
     )

```


```{r,basis-plot-appendix, ref.label=I('basis-plot')}

```

## Longitudinal biomedical data simulation and GAMs{#tumor-data-simulation}

This section describes how to fit GAMs to longitudinal data using simulated data. First, data is simulated according to Section \@ref(longitudinal-GAMs), where reported data of oxygen saturation ($\mbox{StO}_2$) in tumors under either chemotherapy or saline control is used as a starting point to generate individual responses in each group.


```{r,sim-tumor-response-Appendix,echo=TRUE,include=TRUE,message=FALSE,warning=FALSE,eval=FALSE}
dat<-tibble(StO2=c(4,27,3,2,0.5,7,4,50,45,56),
            Day=rep(c(0,2,5,7,10),times=2),
            Group=as.factor(rep(c("Control","Treatment"),each=5))
            )
#alpha for ribbon
al<-0.8


#This function simulates data for the tumor data using default parameters of 10 observations per time point,and Standard deviation (sd) of 5%.
#Because physiologically StO2 cannot go below 0%, data is  generated with a cutoff value of 0.0001 (the "StO2_sim")

simulate_data <- function(dat, n = 10, sd = 5) {
    dat_sim <- dat %>%
        slice(rep(1:n(), each = n)) %>%
        group_by(Group, Day) %>%
        mutate(
               StO2_sim = pmax(rnorm(n, StO2, sd), 0.0001),
               subject=rep(1:10),
               subject=factor(paste(subject, Group, sep = "-"))
               ) %>%
        ungroup()

    return(dat_sim)
}


#subject = factor(paste(subject, treatment, sep = "-")))

n <- 10 #number of observations
sd <- 10 #approximate sd from paper
df <- 6
dat_sim <- simulate_data(dat, n, sd)

#plotting simulated data
f2<-ggplot(dat_sim, aes(x = Day, 
                        y = StO2_sim, 
                        color = Group, 
                        group=subject)) +
    geom_point(show.legend=FALSE,
               size=1.5,
               alpha=0.6)+
    geom_line(size=0.6, alpha=0.4,show.legend=FALSE)+
    geom_line(aes(x = Day, 
               y = StO2,
               color=Group),
           size=1.5,
           data=dat,
           inherit.aes=FALSE,
              show.legend = FALSE)+
  labs(y=expression(atop(StO[2],'(simulated)')))+
  theme_classic()+
  theme(
    axis.text=element_text(size=22)
  )+
    scale_x_continuous(breaks=c(0,2,5,7,10))+
    thm1
  

```

## A basic Workflow for GAMs{#workflow}

This section shows a basic workflow to fit a series of increasingly complex GAMs to the simulated data from the previous section. Graphical and parameter diagnostics for goodness of fit are discussed, as well as model comparison via AIC (Aikake Information Criterion). For simplicity, the confidence intervals (CIs) shown in this section for the models are the across the function CIs created by `mgcv` by default. However, for the pairwise comparisons of the third model we use _simultaneous intervals_ as in the main manuscript, and the code for creating simultaneous CIs for the smooths can be found in Section \@ref(GAM-linear-plot).

### First model

The first model fitted to the data is one that only accounts for different smooths by day. The model syntax specifies that `gam_00` is the object that will contain all the model information, and that the model attempts to explain changes in `StO2_sim` (simulated $\mbox{StO}_2$) using a smooth per `Day`. The model will use 5 basis functions (`k=5`) for the smooth. The smooth is constructed by default using thin plate regression splines. The smoothing parameter estimation method used is the restricted maximum likelihood (`REML`).


```{r, first-GAM, echo=TRUE, include=TRUE, message=FALSE,warning=FALSE}

gam_00<-gam(StO2_sim ~ s(Day, k = 5),
            method='REML',
            data  = dat_sim)

```

To obtain model diagnostics, two methodologies are to be used: 1) graphical diagnostics, and 2) a model check. In the first case, the functions `appraise` and `draw` from the package _gratia_ can be used to obtain a single output with all the graphical diagnostics. For model check, the functions `gam.check` and `summary` from  _mgcv_ provide detailed information about the model fit and its parameters. Keep in mind that `gam.check` is a function that also provides the graphical diagnostics obtained using _gratia_, if such graphical output is not desired the source code can be accessed typing `gam.check` in the Console, and the code without the graphical output can be used in a custom function, which is the approach we follow later).
(ref:first-GAM-caption) Graphical diagnostics for the first GAM model. Left: Graphical diagnostics provided by the function `appraise` from the package _gratia_. Right: Fitted smooth for the model, provided by the function `draw`.


```{r, plotting layouts,echo=TRUE, include=FALSE}

#see https://patchwork.data-imaginist.com/reference/area.html
layout1 <- c(
  area(1, 1),
  area( 1, 2),
  area(2, 1),
  area(2, 2),
  area(1, 3, 2)
)


layout2 <- c(
  area(1, 1),
  area( 1, 2),
  area(2, 1),
  area(2, 2),
  area(1,3,2,5)
)

```

#### Graphical diagnostics


```{r, first-GAM-diag, fig.width=10, fig.height=7, out.width='75%', fig.align='center',echo=FALSE,message=FALSE, warning=FALSE,fig.cap='(ref:first-GAM-caption)'}

appr1<-appraise(gam_00)
sm1<-draw(gam_00)
visual_check<-appr1+sm1

visual_check+plot_layout(design=layout1)
```


From the output of the function `appraise` in Figure \@ref(fig:first-GAM-diag), the major indicators of concern about the model are the QQ plot of residuals and the histogram of residuals. The QQ plot shows that the errors are not reasonably located along the 45$^{\circ}$ line (which indicates normality), as there are multiple points that deviate from the trend, specially in the tails. The histogram also shows that the variation (residuals) is not following the assumption of a normal distribution. 

The `draw` function permits to plot the smooths as `ggplot2` objects, which eases subsequent manipulation, if desired. Because model `gam_00` specifies only one smooth for the time covariate (Day), the plot only contains only one smooth. Note that the smooth shows an almost linear profile.

#### Model check{#gam-00-model-check}

Special attention must be paid to the parameter 'k-index' from `gam.check` (which calls `k.check` to perform the calculation). This parameter indicates if the basis dimension of the smooth is adequate, i.e., it checks that the basis used to create the smooth are adequate to capture the trends in the data. If the model is not adequately capturing the trends in the data, this is indicated by a low k-index value (<1). Because we plot the model diagnostics using `appraise` later, the graphical output from `gam.check` will be suppressed by creating a custom function to obtain just the model estimates, thus avoiding repetition of the diagnostic plots. This will be achieved by calling the source code of `gam.check` and using the appropriate code in a new function that will be called `gam.diagnostics`. We are not including in the Appendix the code for the function `gam.diagnostics` as it is rather long, but if desired it can be accessed by going to the `Appendix.Rmd` file in the GitHub repository and scrolling to this exact place (the code is not included in the final output, but is evaluated to create the function). 

```{r, first-GAM-check, fig.width=10, fig.height=7, out.width='75%', fig.align='center', echo=TRUE, include=FALSE, message=FALSE,warning=FALSE}

#Function that uses the source code of `gam.check` to obtain the estimates without the plots. The source can be checked by typing `gam.check` in the console.
gam.diagnostics<-function (b, old.style = FALSE, type = c("deviance", "pearson", 
    "response"), k.sample = 5000, k.rep = 200, rep = 0, 
    level = 0.9, rl.col = 2, rep.col = "gray80", ...) 
{
    type <- match.arg(type)
    resid <- residuals(b, type = type)
    linpred <- if (is.matrix(b$linear.predictors) && !is.matrix(resid)) 
        napredict(b$na.action, b$linear.predictors[, 1])
    else napredict(b$na.action, b$linear.predictors)
    
    fv <- if (inherits(b$family, "extended.family")) 
        predict(b, type = "response")
    else fitted(b)
    if (is.matrix(fv) && !is.matrix(b$y)) 
        fv <- fv[, 1]
    gamm <- !(b$method %in% c("GCV", "GACV", "UBRE", 
        "REML", "ML", "P-ML", "P-REML", 
        "fREML"))
    if (gamm) {
        cat("\n'gamm' based fit - care required with interpretation.")
        cat("\nChecks based on working residuals may be misleading.")
    }
    else {
        cat("\nMethod:", b$method, "  Optimizer:", 
            b$optimizer)
        if (!is.null(b$outer.info)) {
            if (b$optimizer[2] %in% c("newton", "bfgs")) {
                boi <- b$outer.info
                cat("\n", boi$conv, " after ", boi$iter, 
                  " iteration", sep = "")
                if (boi$iter == 1) 
                  cat(".")
                else cat("s.")
                cat("\nGradient range [", min(boi$grad), 
                  ",", max(boi$grad), "]", sep = "")
                cat("\n(score ", b$gcv.ubre, " & scale ", 
                  b$sig2, ").", sep = "")
                ev <- eigen(boi$hess)$values
                if (min(ev) > 0) 
                  cat("\nHessian positive definite, ")
                else cat("\n")
                cat("eigenvalue range [", min(ev), ",", 
                  max(ev), "].\n", sep = "")
            }
            else {
                cat("\n")
                print(b$outer.info)
            }
        }
        else {
            if (length(b$sp) == 0) 
                cat("\nModel required no smoothing parameter selection")
            else {
                cat("\nSmoothing parameter selection converged after", 
                  b$mgcv.conv$iter, "iteration")
                if (b$mgcv.conv$iter > 1) 
                  cat("s")
                if (!b$mgcv.conv$fully.converged) 
                  cat(" by steepest\ndescent step failure.\n")
                else cat(".\n")
                cat("The RMS", b$method, "score gradient at convergence was", 
                  b$mgcv.conv$rms.grad, ".\n")
                if (b$mgcv.conv$hess.pos.def) 
                  cat("The Hessian was positive definite.\n")
                else cat("The Hessian was not positive definite.\n")
            }
        }
        if (!is.null(b$rank)) {
            cat("Model rank = ", b$rank, "/", length(b$coefficients), 
                "\n")
        }
    }
    cat("\n")
    kchck <- k.check(b, subsample = k.sample, n.rep = k.rep)
    if (!is.null(kchck)) {
        cat("Basis dimension (k) checking results. Low p-value (k-index<1) may\n")
        cat("indicate that k is too low, especially if edf is close to k'.\n\n")
        printCoefmat(kchck, digits = 3)
    }
}
```

We now call `gam.diagnostics` to provide the desired diagnostic output, as well as a summary of the fitted model, which is obtained by calling `summary`.

```{r,gam-00-diagnostics, echo=TRUE, include=TRUE}
gam.diagnostics(gam_00)

```

From the output, it can be seen that the `k-index` is 0.36, which indicates that the model is not capturing the variability in the data. The `edf` (effective degrees of freedom) is an indicator of the complexity of the smooth. Here the complexity of the smooth is comparable to that of a 4th degree polynomial.

```{r, summary-gam_00}
summary(gam_00)

```

From the `summary` function, information about the assumed distribution of the errors (Gaussian in this case) and the link function can be obtained. The link function is 'identity' as the model does not make any transformation on the predictors. The 'significance of smooth terms' _p-value_ indicates if each smooth is adding significance to the model. Here, the _p-value_ is low but we have seen that there are issues with the model from the previous outputs. Finally, the 'deviance explained' indicates how much of the data the model is able to capture, which in this case corresponds to $\approx$ 17%.

### Second model

The major flaw of `gam_00` is that this model is not taking into account the fact that the data is nested in groups. The next iteration is a model where a different smooth of time (Day) is assigned for each group using `by = Group` in the model syntax.


```{r, second-GAM, echo=TRUE, fig.width=10, fig.height=7, out.width='75%', fig.align='center', include=TRUE, message=FALSE,warning=FALSE}

gam_01<-gam(StO2_sim ~ s(Day, by=Group,k = 5),
            method ='REML',
            data  = dat_sim)

gam.diagnostics(gam_01)
```

Diagnostics for this model indicate that the k-index is still below 1 (0.43 from `gam.check`), and that the residuals are still not following a normal distribution (Figure  \@ref(fig:second-GAM-diag)). Moreover, the smooths (plotted via the `draw()` function) appear with a fairly linear profile, which indicates they are still not capturing the trends observed in the data.

```{r,summary-gam_01}

summary(gam_01)
```

From `summary()`, the deviance explained by the model is $\approx$ 51%.

(ref:second-GAM-caption) Graphical diagnostics for the second GAM model. Left: Graphical diagnostics provided by the function `appraise` from the package _gratia_. Right: Fitted smooth for the model, provided by the function `draw`.

```{r, second-GAM-diag, fig.width=10, fig.height=7, out.width='75%', fig.align='center',echo=FALSE,message=FALSE, warning=FALSE,fig.cap='(ref:second-GAM-caption)'}
#need to add figure number and caption
appr2<-appraise(gam_01)
sm2<-draw(gam_01)

visual_check2<-appr2+sm2

visual_check2+plot_layout(design=layout1)
```

### Third model

Model `gam_00` was built for didactic purposes to cover the simplest case, but it does not account for the nesting of the data by Group, which is apparent from the type of smooth fitted (a single smooth), the model diagnostics, and, the low variance explained by the model. On the other hand, `gam_01` takes into account the nesting within each group and provides better variance explanation, but as indicated in Section \@ref(longitudinal-GAMs), in order to differentiate between each group a parametric term needs to be added to the model for the interaction of _Day_ and _Group_. 

This is because in `gam_01`  separate smooths were fitted per group and those smooths also tried to account for the different means of the response in the two groups. Adding a parametric term for `Group` enables the smooths to capture the time course-differences of each group. The resulting model is `gam_02`, which is the model fitted in the main manuscript. 


```{r,final-model-Appendix,fig.width=10, fig.height=7, out.width='75%', fig.align='center', echo=TRUE,include=TRUE,message=FALSE,warning=FALSE}

#GAM for StO2

gam_02 <- gam(StO2_sim ~ Group+s(Day, by = Group, k = 5),
            method='REML',
            data  = dat_sim)

gam.diagnostics(gam_02)


```

By using `appraise()` and `draw` on this model (Figure  \@ref(fig:final-GAM-diag)) we see that the trend on the QQ plot has improved, the histogram of the residuals appears to be reasonably distributed, and the smooths are capturing the trend of the data within each group. From `gam.check`, the k-index is now at an acceptable value ($\approx$ 1.02).

```{r,summary-gam_02}
summary(gam_02)
```

From `summary`, the model is able to capture 89% of the variance in the data, which is a substantial improvement over the variance explained by `gam_00` and `gam_01`.

(ref:final-GAM-caption) Graphical diagnostics for the final GAM model. Left: Graphical diagnostics provided by the function `appraise` from the package _gratia_. Right: Fitted smooths for the model, provided by the function `draw`.

```{r, final-GAM-diag, fig.width=10, fig.height=7, out.width='75%', fig.align='center',echo=FALSE,message=FALSE, warning=FALSE,fig.cap='(ref:final-GAM-caption)'}

appr3<-appraise(gam_02)
sm3<-draw(gam_02)

visual_check3<-appr3+sm3

visual_check3+plot_layout(design=layout2)
```


### Comparing models via AIC

One final  comparison that can be made for model selection involves the use of the Aikake Information Criterion (AIC). This metric is used to estimate information loss, which we want to minimize with an appropriate model. Therefore, when 2 or more models are compared, the model with lower AIC is preferred. In R, the comparison is done using the `AIC` function.

```{r,model-selection-AIC}

AIC(gam_00,gam_01,gam_02)

```

The output in this case is expected: model `gam_02` has a lower AIC (712.46) whereas the initial two models have higher AICs (900 and 858). The AIC should not be considered as the only estimator of model quality, instead to be used as complimentary information to the graphical diagnostics and model checks described above.

#### Pairwise comparisons of smooth confidence intervals

The estimation of significant differences between each treatment group can be achieved via pairwise comparisons of the smooth confidence intervals as described in section \@ref(GAM-significance). 



In this case, the "design matrix" is used to estimate the pairwise comparisons (see main manuscript for details and associated references). Briefly, the "design matrix" (also known as the "Xp matrix") from the selected model (`gam_02`) is used to calculate a 95% confidence interval of the difference between the smooth terms for each group. This approach allows to estimate the time intervals where a significant difference exists between the groups (confidence interval above or below 0). 

We want to emphasize that for the model used here we have included the group means in order to keep the pairwise comparisons on the scale of the response (a change from the code which appears in the chunk with a comment that says `###IMPORTANT`). This approach works well for models like `gam_02` but implementing this on models with more parametric terms can be challenging. However, we do believe that the model presented in the paper covers a wide range of situations and our approach here for the pairwise comparisons will be useful for most biomedical researchers.

```{r,pairwise-comp-workflow,echo=TRUE,include=TRUE,message=FALSE,warning=FALSE}
##Pairwise comparisons
difference_pointwise <- function(f1, f2, smooth, by_var, smooth_var, data, Xp, V, coefs, nrep = 1000) {
  ## make sure f1 and f2 are characters
  f1 <-  as.character(f1)
  f2 <-  as.character(f2)
  cnames <- colnames(Xp)
  ## columns of Xp associated with pair of smooths
  c1 <- grepl(gratia:::mgcv_by_smooth_labels(smooth, by_var, f1), cnames, fixed = TRUE)
  c2 <- grepl(gratia:::mgcv_by_smooth_labels(smooth, by_var, f2), cnames, fixed = TRUE)
  ## rows of Xp associated with pair of smooths
  r1 <- data[[by_var]] == f1
  r2 <- data[[by_var]] == f2

  ## difference rows of Xp for pair of smooths
  X <- Xp[r1, ] - Xp[r2, ]

  ### IMPORTANT: Keep group means####
  ## zero the cols related to other splines
 # X[, ! (c1 | c2)] <- 0

  ## zero out the parametric cols
  #X[, !grepl('^s\\(', cnames)] <- 0

  ## compute difference
  sm_diff <- drop(X %*% coefs)
  se <- sqrt(rowSums((X %*% V) * X))
  nr <- NROW(X)

  ## Calculate posterior simulation for smooths
  coefs_sim <- t(rmvn(nrep, rep(0, nrow(V)), V))
  rownames(coefs_sim) <- rownames(V)
  simDev <- X %*% coefs_sim
  absDev <- abs(sweep(simDev, 1, se, FUN = "/"))
  masd <- apply(absDev, 2, max)
  crit_s <- quantile(masd, prob = 0.95, type = 8)


  out <- list(smooth = rep(smooth, nr), by = rep(by_var, nr),
              level_1 = rep(f1, nr),
              level_2 = rep(f2, nr),
              diff = sm_diff, se = se,
              lower_s = sm_diff - crit_s * se,
              upper_s = sm_diff + crit_s*se)

  out <- new_tibble(out, nrow = NROW(X), class = "difference_smooth")
  ## Only need rows associated with one of the levels
  out <- bind_cols(out, data[r1, smooth_var])

  out
}

#does both ci and si
difference_smooths <- function(model,
                                 smooth,
                                 n = 100,
                                 ci_level = 0.95,
                                 newdata = NULL,
                                 partial_match = TRUE,
                                 unconditional = FALSE,
                                 frequentist = FALSE,
                                 nrep = 10000,
                                 include_means = TRUE,
                                 ...) {
  if (missing(smooth)) {
    stop("Must specify a smooth to difference via 'smooth'.")
  }

  # smooths in model
  S <- gratia::smooths(model) # vector of smooth labels - "s(x)"
  # select smooths
  select <-
    gratia:::check_user_select_smooths(smooths = S, select = smooth,
                                       partial_match = partial_match)#,
  # model_name = expr_label(substitute(object)))
  sm_ids <- which(select)
  smooths <- gratia::get_smooths_by_id(model, sm_ids)
  sm_data <- map(sm_ids, gratia:::smooth_data,
                 model = model, n = n, include_all = TRUE)
  sm_data <- bind_rows(sm_data)
  by_var <- by_variable(smooths[[1L]])
  smooth_var <- gratia:::smooth_variable(smooths[[1L]])
  pairs <- as_tibble(as.data.frame(t(combn(levels(sm_data[[by_var]]), 2)),
                                   stringsAsFactor = FALSE))
  names(pairs) <- paste0("f", 1:2)

  Xp <- predict(model, newdata = sm_data, type = "lpmatrix")
  V <- gratia:::get_vcov(model, unconditional = unconditional,
                         frequentist = frequentist)
  coefs <- coef(model)

  out <- pmap(pairs, difference_pointwise, smooth = smooth, by_var = by_var,
              smooth_var = smooth_var, data = sm_data, Xp = Xp, V = V,
              coefs = coefs, nrep = nrep)
  out <- bind_rows(out)
  crit <- qnorm((1 - ci_level) / 2, lower.tail = FALSE)

  out <- add_column(out,
                    lower = out$diff - (crit * out$se),
                    upper = out$diff + (crit * out$se),
                    .after = 6L)
  out
}

#compute difference between smooths and calculate confidence interval: complete data
diff_complete <- difference_smooths(gam_02, smooth = "s(Day)", newdata = newdat,
                     unconditional = TRUE, frequentist = FALSE,
                     n=100, partial_match = TRUE, nrep=10000)


#function to obtain values for the shading regions
pairwise_limits<-function(dataframe){
    #extract values where the lower limit of the ribbon is greater than zero
    #this is the region where the control group effect is greater

    v1<-dataframe%>%
        filter(lower_s>0)%>%
        select(Day)
    #get day  initial value
    init1=v1$Day[[1]]
    #get day final value
    final1=v1$Day[[nrow(v1)]]
    #extract values where the value of the upper limit of the ribbon is lower than zero
    #this corresponds to the region where the treatment group effect is greater
    v2<-dataframe%>%
        filter(upper_s<0)%>%
        select(Day)

    init2=v2$Day[[1]]
    final2=v2$Day[[nrow(v2)]]
    #store values
    my_list<-list(init1=init1,
                  final1=final1,
                  init2=init2,
                  final2=final2)
    return(my_list)

    

}

my_list<-pairwise_limits(diff_complete)
rib_col<-'#8D7D82' #color for ribbon for confidence interval
control_rib <- '#875F79' #color for ribbon for control region
treat_rib <- '#A7D89E' #color for ribbon treatment region

c1 <- ggplot() +
  geom_line(data = diff_complete, aes(x = Day, y = diff),size=1, alpha=0.5) +
    annotate("rect",
                xmin =my_list$init1, xmax =my_list$final1,ymin=-Inf,ymax=Inf,
                fill=control_rib,
                alpha = 0.5,
                )+
    annotate("text",
             x=1.5,
             y=-18,
             label="Control>Treatment",
           size=6,
           angle=90
           )+
    annotate("rect",
             xmin =my_list$init2, xmax =my_list$final2,ymin=-Inf,ymax=Inf,
             fill=treat_rib,
             alpha = 0.5
             ) +
  annotate("text",
             x=6,
             y=-18,
             label="Treatment>Control",
             size=6,
           angle=90
           )+
  geom_ribbon(data = diff_complete, aes(x = Day, ymin = lower_s, ymax = upper_s),
              alpha = 0.5, fill = rib_col, inherit.aes = FALSE) +
  geom_hline(yintercept = 0, lty = 2, color = "red")+
    scale_x_continuous(breaks=c(0,2,5,7,10))+
    labs(y="Difference\n(Complete observations)")+
    theme_classic()+
    theme(
    axis.text=element_text(size=22))
    
```

(ref:pairwise-comp-caption) Smooth pairwise comparisons for model `gam_02` using a 95% simultaneous CI for the difference between smooths. The comparison includes the group means and therefore can be directly correlated with the magnitude of the response. Shaded regions indicate time intervals where each treatment group has a non-zero effect. 

```{r, pairwise-comp-workflow-fig, fig.width=10, fig.height=7, out.width='75%', fig.align='center',echo=FALSE,message=FALSE, warning=FALSE,fig.cap='(ref:pairwise-comp-caption)'}
c1
```

Of notice, the package `gratia` contains a function that allows to do pairwise comparisons. In this package, `difference_smooths` is a function that makes the comparisons and produces Figure \@ref(fig:pairwise-comp-workflow-fig) when is used on a fitted model. The function syntax and an example can be found at:

https://cran.r-project.org/web/packages/gratia/gratia.pdf

Keep in mind that this function removes the group means for the pairwise comparison so the result will not be directly interpretable with the scale of the measured response.


## GAM and Linear model plots and Missing data

This section covers the code used to generate Figure \@ref(fig:sim-smooth-plot), where the simulated data, fit of the "final" GAM (`gam_02`), linear model  and GAM on data with missing observations are presented. Note that panel A in Figure \@ref(fig:sim-smooth-plot) and the inset are generated in the code chunk where the data is simulated in Section \@ref(tumor-data-simulation), and are called later to build the figure.

### GAM and Linear model plots{#GAM-linear-plot}

This code chunk creates panels B and C in Figure \@ref(fig:sim-smooth-plot). Note that this code uses the final GAM from the previous section (`gam_02`), so the simulated data and the model should be generated before running this section. 

```{r, plotting-appendix, echo=TRUE, include=TRUE, message=FALSE, warning=FALSE,eval=FALSE}
#linear model
lm1<-lm(StO2_sim ~ Day + Group + Day * Group, data = dat_sim)

## point-wise interval
ci <- confint(gam_02, parm = "s(Day)", partial_match = TRUE, type = "confidence")
## simultaneous interval
si <- confint(gam_02, parm = "s(Day)", type = "simultaneous", partial_match = TRUE)


# mean shift for Treatment group
const <- coef(gam_02)[2]

#pointwise confidence interval
ci <- ci %>%
mutate(est = case_when(Group == "Treatment" ~ est + const,
TRUE ~ est),
lower = case_when(Group == "Treatment" ~ lower + const,
TRUE ~ lower),
upper = case_when(Group == "Treatment" ~ upper + const,
TRUE ~ upper))

#simultaneous interval
si <- si %>%
mutate(est = case_when(Group == "Treatment" ~ est + const,
TRUE ~ est),
lower = case_when(Group == "Treatment" ~ lower + const,
TRUE ~ lower),
upper = case_when(Group == "Treatment" ~ upper + const,
TRUE ~ upper))


#creates a dataframe using the length of the covariates for rm-ANOVA
lm_predict<-expand_grid(Group = factor(c("Control", "Treatment")),
                         Day = c(0:10),
                        subject=factor(rep(1:10)),
                          )
lm_predict$subject<-factor(paste(lm_predict$subject, lm_predict$Group, sep = "-"))

#using lm
lm_predict<-lm_predict%>%
    mutate(fit = predict(lm1,lm_predict,se.fit = TRUE,type='response')$fit,
           se.fit = predict(lm1, lm_predict,se.fit = TRUE,type='response')$se.fit)

#plot smooths and pointwise and simulatenous confidence intervals for GAM
f3<-ggplot(ci, aes(x = Day, y = est, group = smooth)) +
geom_line(lwd = 1) +
geom_ribbon(data = ci, mapping = aes(ymin = lower, ymax = upper, x = Day, group = smooth,fill = Group),
inherit.aes = FALSE, alpha = 0.7,
show.legend=FALSE) +
geom_ribbon(data = si,
mapping = aes(ymin = lower, ymax = upper, x = Day, group = smooth,fill =Group),
inherit.aes = FALSE, alpha = 0.3,
show.legend=FALSE)+
    geom_point(data=dat_sim, aes(x = Day, 
                        y = StO2_sim, 
                        color = Group), 
                        size=1.5,
                        alpha=0.6, 
               inherit.aes = FALSE,
               show.legend = FALSE)+
    geom_line(data=si,aes(Day,upper,color=Group), size=0.8, alpha=0.7)+
    geom_line(data=si,aes(Day,lower,color=Group), size=0.8, alpha=0.7)+
    labs(y=expression(atop(StO[2],'(complete observations)')))+
    scale_x_continuous(breaks=c(0,2,5,7,10))+
      theme_classic()+
  theme(
    axis.text=element_text(size=22)
  )+thm1

 
#plot linear fit for rm-ANOVA
f4<-ggplot(data=dat_sim, aes(x=Day, y=StO2_sim, group=Group)) +
    geom_point(aes(color=Group),size=1.5,alpha=0.5,show.legend = FALSE)+
  geom_ribbon(aes( x=Day,ymin=(fit - 2*se.fit), 
                   ymax=(fit + 2*se.fit),fill=Group),
              alpha=al,
              data=lm_predict,
              show.legend = FALSE,
                inherit.aes=FALSE) +
  geom_line(aes(y=fit,
                color=Group),
              size=1,data=lm_predict,
              show.legend = FALSE)+
  #facet_wrap(~Group)+
  labs(y=expression(paste('StO'[2],' (simulated)')))+
    scale_x_continuous(breaks=c(0,2,5,7,10))+
      theme_classic()+
  theme(
    axis.text=element_text(size=22)
  )+thm1

```

## Working with Missing data in GAMs

This code chunk first randomly deletes 40% of the total observations in the original simulated data, and then an interaction GAM is fitted to the remaining data. Model diagnostics are presented, and an object that stores the fitted smooths is saved to be called in the final code chunk to build the figure.

```{r,missing-data-Appendix,echo=TRUE,include=TRUE,message=FALSE,warning=FALSE,eval=FALSE}
#missing data
#create a sequence of 40 random numbers between 1 and 100, these numbers will
#correspond to the row numbers to be randomly erased from the original dataset
missing <- sample(1:100, 40)

#create a new dataframe from the simulated data with 40 rows randomly removed, keep the missing values as NA

ind <- which(dat_sim$StO2_sim %in% sample(dat_sim$StO2_sim, 40))

#create a new dataframe, remove the StO2 column
dat_missing <- dat_sim[,-1]

#add NAs at the ind positions
dat_missing$StO2_sim[ind]<-NA 

#Count the number of remaining observations per day (original dataset had 10 per group per day)
dat_missing %>%
    group_by(Day,Group) %>%
    filter(!is.na(StO2_sim))%>%
  count(Day)


#the same model used for the full dataset
mod_m1 <- gam(StO2_sim ~ Group+s(Day,by=Group,k=5), data  = dat_missing,family=scat)
#appraise the model
appraise(mod_m1)


ci <- confint(mod_m1, parm = "s(Day)", partial_match = TRUE, type = "confidence")
## simultaneous interval
si <- confint(mod_m1, parm = "s(Day)", type = "simultaneous", partial_match = TRUE)


# mean shift for group 2
const <- coef(mod_m1)[2]

ci <- ci %>%
mutate(est = case_when(Group == "Treatment" ~ est + const,
TRUE ~ est),
lower = case_when(Group == "Treatment" ~ lower + const,
TRUE ~ lower),
upper = case_when(Group == "Treatment" ~ upper + const,
TRUE ~ upper))

si <- si %>%
mutate(est = case_when(Group == "Treatment" ~ est + const,
TRUE ~ est),
lower = case_when(Group == "Treatment" ~ lower + const,
TRUE ~ lower),
upper = case_when(Group == "Treatment" ~ upper + const,
TRUE ~ upper))

#plot model and original data
f6<-ggplot(ci, aes(x = Day, y = est, group = smooth)) +
geom_line(lwd = 1) +
geom_ribbon(data = ci, mapping = aes(ymin = lower, ymax = upper, x = Day, group = smooth,fill = Group),
inherit.aes = FALSE, alpha = 0.7,
show.legend=FALSE) +
geom_ribbon(data = si,
mapping = aes(ymin = lower, ymax = upper, x = Day, group = smooth,fill =Group),
inherit.aes = FALSE, alpha = 0.4,
show.legend=TRUE)+
    geom_line(data=si,aes(Day,upper,color=Group), size=0.8, alpha=0.7)+
    geom_line(data=si,aes(Day,lower,color=Group), size=0.8, alpha=0.7)+
    geom_point(data=dat_missing, aes(x = Day, 
                        y = StO2_sim, 
                        color = Group), 
                            size=1.5,
                        alpha=0.6, 
               inherit.aes = FALSE)+
    labs(y=expression(atop(StO[2],'(missing observations)')))+
    scale_x_continuous(breaks=c(0,2,5,7,10))+
      theme_classic()+
  theme(
    axis.text=element_text(size=22))+
        thm1


```



```{r,sim-smooth-plot-Appendix, ref.label=I('sim-smooth-plot')}


```


## Pairwise comparisons in GAMs: full and missing data cases

The next code chunk reproduces Figure \@ref(fig:plot-pairwise-comp). Here pairwise comparisons are made for the full and missing datasets by computing the difference between the smooths and a 95% simultaneous CI.


```{r,pairwise-comp-Appendix,include=TRUE,message=FALSE,warning=FALSE, eval=FALSE}
##Pairwise comparisons


difference_pointwise <- function(f1, f2, smooth, by_var, smooth_var, data, Xp, V, coefs, nrep = 1000) {
  ## make sure f1 and f2 are characters
  f1 <-  as.character(f1)
  f2 <-  as.character(f2)
  cnames <- colnames(Xp)
  ## columns of Xp associated with pair of smooths
  c1 <- grepl(gratia:::mgcv_by_smooth_labels(smooth, by_var, f1), cnames, fixed = TRUE)
  c2 <- grepl(gratia:::mgcv_by_smooth_labels(smooth, by_var, f2), cnames, fixed = TRUE)
  ## rows of Xp associated with pair of smooths
  r1 <- data[[by_var]] == f1
  r2 <- data[[by_var]] == f2

  ## difference rows of Xp for pair of smooths
  X <- Xp[r1, ] - Xp[r2, ]

  ## zero the cols related to other splines
 # X[, ! (c1 | c2)] <- 0

  ## zero out the parametric cols
  #X[, !grepl('^s\\(', cnames)] <- 0

  ## compute difference
  sm_diff <- drop(X %*% coefs)
  se <- sqrt(rowSums((X %*% V) * X))
  nr <- NROW(X)

  ## Calculate posterior simulation for smooths
  coefs_sim <- t(rmvn(nrep, rep(0, nrow(V)), V))
  rownames(coefs_sim) <- rownames(V)
  simDev <- X %*% coefs_sim
  absDev <- abs(sweep(simDev, 1, se, FUN = "/"))
  masd <- apply(absDev, 2, max)
  crit_s <- quantile(masd, prob = 0.95, type = 8)


  out <- list(smooth = rep(smooth, nr), by = rep(by_var, nr),
              level_1 = rep(f1, nr),
              level_2 = rep(f2, nr),
              diff = sm_diff, se = se,
              lower_s = sm_diff - crit_s * se,
              upper_s = sm_diff + crit_s*se)

  out <- new_tibble(out, nrow = NROW(X), class = "difference_smooth")
  ## Only need rows associated with one of the levels
  out <- bind_cols(out, data[r1, smooth_var])

  out
}

#does both ci and si
difference_smooths <- function(model,
                                 smooth,
                                 n = 100,
                                 ci_level = 0.95,
                                 newdata = NULL,
                                 partial_match = TRUE,
                                 unconditional = FALSE,
                                 frequentist = FALSE,
                                 nrep = 10000,
                                 include_means = TRUE,
                                 ...) {
  if (missing(smooth)) {
    stop("Must specify a smooth to difference via 'smooth'.")
  }

  # smooths in model
  S <- gratia::smooths(model) # vector of smooth labels - "s(x)"
  # select smooths
  select <-
    gratia:::check_user_select_smooths(smooths = S, select = smooth,
                                       partial_match = partial_match)#,
  # model_name = expr_label(substitute(object)))
  sm_ids <- which(select)
  smooths <- gratia::get_smooths_by_id(model, sm_ids)
  sm_data <- map(sm_ids, gratia:::smooth_data,
                 model = model, n = n, include_all = TRUE)
  sm_data <- bind_rows(sm_data)
  by_var <- by_variable(smooths[[1L]])
  smooth_var <- gratia:::smooth_variable(smooths[[1L]])
  pairs <- as_tibble(as.data.frame(t(combn(levels(sm_data[[by_var]]), 2)),
                                   stringsAsFactor = FALSE))
  names(pairs) <- paste0("f", 1:2)

  Xp <- predict(model, newdata = sm_data, type = "lpmatrix")
  V <- gratia:::get_vcov(model, unconditional = unconditional,
                         frequentist = frequentist)
  coefs <- coef(model)

  out <- pmap(pairs, difference_pointwise, smooth = smooth, by_var = by_var,
              smooth_var = smooth_var, data = sm_data, Xp = Xp, V = V,
              coefs = coefs, nrep = nrep)
  out <- bind_rows(out)
  crit <- qnorm((1 - ci_level) / 2, lower.tail = FALSE)

  out <- add_column(out,
                    lower = out$diff - (crit * out$se),
                    upper = out$diff + (crit * out$se),
                    .after = 6L)
  out
}

#compute difference between smooths and calculate confidence interval: complete data
diff_complete <- difference_smooths(gam_02, smooth = "s(Day)", newdata = newdat,
                     unconditional = TRUE, frequentist = FALSE,
                     n=100, partial_match = TRUE, nrep=10000)


#function to obtain values for the shading regions
pairwise_limits<-function(dataframe){
    #extract values where the lower limit of the ribbon is greater than zero
    #this is the region where the control group effect is greater

    v1<-dataframe%>%
        filter(lower_s>0)%>%
        select(Day)
    #get day  initial value
    init1=v1$Day[[1]]
    #get day final value
    final1=v1$Day[[nrow(v1)]]
    #extract values where the value of the upper limit of the ribbon is lower than zero
    #this corresponds to the region where the treatment group effect is greater
    v2<-dataframe%>%
        filter(upper_s<0)%>%
        select(Day)

    init2=v2$Day[[1]]
    final2=v2$Day[[nrow(v2)]]
    #store values
    my_list<-list(init1=init1,
                  final1=final1,
                  init2=init2,
                  final2=final2)
    return(my_list)

    

}

my_list<-pairwise_limits(diff_complete)
rib_col<-'#8D7D82' #color for ribbon for confidence interval
control_rib <- '#875F79' #color for ribbon for control region
treat_rib <- '#A7D89E' #color for ribbon treatment region

c1 <- ggplot() +
  geom_line(data = diff_complete, aes(x = Day, y = diff),size=1, alpha=0.5) +
    annotate("rect",
                xmin =my_list$init1, xmax =my_list$final1,ymin=-Inf,ymax=Inf,
                fill=control_rib,
                alpha = 0.5,
                )+
    annotate("text",
             x=1.5,
             y=-18,
             label="Control>Treatment",
           size=6,
           angle=90
           )+
    annotate("rect",
             xmin =my_list$init2, xmax =my_list$final2,ymin=-Inf,ymax=Inf,
             fill=treat_rib,
             alpha = 0.5
             ) +
  annotate("text",
             x=6,
             y=-18,
             label="Treatment>Control",
             size=6,
           angle=90
           )+
  geom_ribbon(data = diff_complete, aes(x = Day, ymin = lower_s, ymax = upper_s),
              alpha = 0.5, fill = rib_col, inherit.aes = FALSE) +
  geom_hline(yintercept = 0, lty = 2, color = "red")+
    scale_x_continuous(breaks=c(0,2,5,7,10))+
    labs(y="Difference\n(Complete observations)")+
    theme_classic()+
    theme(
    axis.text=element_text(size=22))
    
    

###compute difference in smooths for missing data
diff_missing <- difference_smooths(mod_m1, smooth = "s(Day)", newdata = newdat,
                     unconditional = TRUE, frequentist = FALSE,
                     n=100, partial_match = TRUE, nrep=10000)

v2<- diff_missing %>%
        filter(upper_s<0)%>%
        select(Day)
init2=v2$Day[[1]]
final2=v2$Day[[nrow(v2)]]

c2 <- ggplot() +
  geom_line(data = diff_missing, aes(x = Day, y = diff),size=1, alpha=0.5) +
    annotate("rect",
             xmin =init2, xmax = final2,ymin=-Inf,ymax=Inf,
             fill=treat_rib,
             alpha = 0.5,
    ) +
  annotate("text",
             x=6,
             y=-18,
             label="Treatment>Control",
             size=6,
           angle=90
           )+
  geom_ribbon(data = diff_missing, aes(x = Day, ymin = lower_s, ymax = upper_s),
              alpha = 0.5, fill = rib_col, inherit.aes = FALSE) +
  geom_hline(yintercept = 0, lty = 2, color = "red")+
    scale_x_continuous(breaks=c(0,2,5,7,10))+
    labs(y="Difference\n(Missing observations)")+
    theme_classic()+
    theme(
    axis.text=element_text(size=22))
    


pair_comp<-c1+c2
```


```{r,plot-pairwise-comp-Appendix,ref.label=I('plot-pairwise-comp')}

```

